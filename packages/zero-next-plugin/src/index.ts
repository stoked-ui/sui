import type { NextConfig } from 'next';
import type * as NextServer from 'next/dist/server/config-shared';
import path from 'path';
import type * as Webpack from 'webpack';
import { generateCss } from '@mui/zero-tag-processor/generateCss';

import type { PluginOptions, Preprocessor } from '@linaria/babel-preset';
import type { LinariaLoaderOptions } from './loaders/transformLoader';
import { regexLinariaCSS, regexLinariaGlobalCSS } from './loaders/transformLoader';
import ErrorPlugin from './plugins/errorPlugin';
import { isCssLoader, isCssModule } from './utils';
import VirtualModuleStore from './VirtualModuleStore';

export interface ZeroPluginOptions extends PluginOptions {
  /**
   * An object of the themes that you want passed in as an argument in the callback argument of `styled`.
   */
  theme: unknown;
  /**
   * Prefix string to use in the generated css variables.
   */
  cssVariablesPrefix?: string;
  /**
   * Whether the css variables for the default theme should target the :root selector or not.
   * @default true
   */
  injectDefaultThemeInRoot?: boolean;
  // exclude?: FilterPattern;
  sourceMap?: boolean;
  preprocessor?: Preprocessor;
}

// Thanks https://github.com/Mistereo/next-linaria/blob/de4fd15269bd059e35797bb7250ce84cc8c5067c/index.js#L3
// for the inspiration
function traverseLoaders(rules: Webpack.RuleSetRule[]) {
  for (let i = 0; i < rules.length; i += 1) {
    const rule = rules[i];
    if (isCssLoader(rule)) {
      if (isCssModule(rule)) {
        const nextGetLocalIdent = rule.options.modules.getLocalIdent;
        const nextMode = rule.options.modules.mode;

        // allow global css for *.linaria.global.css files
        rule.options.modules.mode = (innerPath) => {
          const isGlobal = regexLinariaGlobalCSS.test(innerPath);
          if (isGlobal) {
            return 'local';
          }
          return typeof nextMode === 'function' ? nextMode(innerPath) : nextMode;
        };

        // We don't want the default css-loader to generate classnames
        // for linaria modules, since those are generated by linaria.
        rule.options.modules.getLocalIdent = (context, _, exportName, ...rest) => {
          if (regexLinariaCSS.test(context.resourcePath)) {
            return exportName;
          }
          return nextGetLocalIdent(context, _, exportName, ...rest);
        };
      }
    }
    if (typeof rule.use === 'object') {
      // FIXME: Can we do it without the typecast?
      const useRules = rule.use as Webpack.RuleSetRule | Webpack.RuleSetRule[];
      traverseLoaders(Array.isArray(useRules) ? useRules : [useRules]);
    }
    if (Array.isArray(rule.oneOf)) {
      traverseLoaders(rule.oneOf as Webpack.RuleSetRule[]);
    }
  }
}

let moduleStore: VirtualModuleStore;

export default function withZero(nextConfig: NextConfig, zeroConfig: ZeroPluginOptions) {
  const {
    theme,
    cssVariablesPrefix = 'mui',
    injectDefaultThemeInRoot = true,
    babelOptions = {},
    sourceMap = false,
    displayName = false,
  } = zeroConfig;

  const webpack = (config: Webpack.Configuration, options: NextServer.WebpackConfigContext) => {
    if (config.module?.rules && config.plugins) {
      traverseLoaders(config.module.rules as Webpack.RuleSetRule[]);

      // Add our store for virtual linaria css modules
      if (!moduleStore) {
        moduleStore = new VirtualModuleStore(config);
      }
      const vmPlugin = moduleStore.createStore(config.name);
      vmPlugin.writeModule(
        'node_modules/@mui/zero-runtime/styles.css',
        generateCss(
          {
            cssVariablesPrefix,
            themeArgs: {
              theme,
            },
          },
          {
            defaultThemeKey: 'theme',
            injectInRoot: injectDefaultThemeInRoot,
          },
        ),
      );
      config.plugins.push(vmPlugin);

      // Show message when linaria cache is out of sync with webpack
      config.plugins.push(new ErrorPlugin());

      // Add css output loader with access to the module store
      // in order to set the correct dependencies
      config.module.rules.push({
        test: regexLinariaCSS,
        exclude: /node_modules/,
        use: [
          {
            loader: path.resolve(__dirname, './loaders/outputCssLoader'),
            options: {
              moduleStore,
            },
          },
        ],
      });

      // Add linaria loader to transform files
      const linariaLoaderOptions: LinariaLoaderOptions = {
        ...zeroConfig,
        babelOptions: {
          ...babelOptions,
          presets: [...(babelOptions.presets ?? []), 'next/babel', '@linaria'],
        },
        themeArgs: {
          theme,
        },
        sourceMap: sourceMap ?? process.env.NODE_ENV !== 'production',
        displayName: displayName ?? process.env.NODE_ENV !== 'production',
        moduleStore,
      };
      config.module.rules.push({
        test: /\.(tsx|ts|js|mjs|jsx)$/,
        exclude: /node_modules/,
        use: [
          {
            loader: path.resolve(__dirname, './loaders/transformLoader'),
            options: linariaLoaderOptions,
          },
        ],
      });
    }

    if (typeof nextConfig.webpack === 'function') {
      return nextConfig.webpack(config, options);
    }
    return config;
  };

  return {
    ...nextConfig,
    webpack,
  };
}
