import { useEffect, useRef, useState, useCallback } from 'react';

/**
 * Layer transform interface matching WASM bindings
 */
export interface WasmTransform {
  x: number;
  y: number;
  scale_x: number;
  scale_y: number;
  rotation: number;
  opacity: number;
}

/**
 * Layer interface matching WASM bindings
 */
export interface WasmLayer {
  id: string;
  type: 'solidColor' | 'image' | 'text';
  color?: [number, number, number, number];
  transform: WasmTransform;
  blend_mode?: 'normal' | 'multiply' | 'screen' | 'overlay' | 'add' | 'lighten' | 'darken';
  visible: boolean;
  z_index: number;
}

/**
 * WASM renderer instance interface (generated by wasm-bindgen)
 */
interface PreviewRendererInstance {
  render_frame(layersJson: string): void;
  clear(): void;
  get_metrics(): string;
  free(): void;
}

/**
 * WASM renderer constructor interface
 */
interface PreviewRendererConstructor {
  new (canvas: HTMLCanvasElement, width: number, height: number): PreviewRendererInstance;
}

/**
 * WASM module interface
 */
interface WasmModule {
  PreviewRenderer: PreviewRendererConstructor;
  benchmark_composition(width: number, height: number, layerCount: number): number;
}

/**
 * Performance metrics from WASM renderer
 */
export interface RenderMetrics {
  width: number;
  height: number;
  ready: boolean;
  lastFrameTime?: number;
  fps?: number;
}

/**
 * Hook for using WASM preview renderer
 */
export function useWasmRenderer(width: number, height: number) {
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  const [metrics, setMetrics] = useState<RenderMetrics | null>(null);

  const canvasRef = useRef<HTMLCanvasElement>(null);
  const rendererRef = useRef<PreviewRendererInstance | null>(null);
  const wasmModuleRef = useRef<WasmModule | null>(null);

  /**
   * Load WASM module
   */
  useEffect(() => {
    let cancelled = false;

    async function loadWasm() {
      try {
        setIsLoading(true);
        setError(null);

        // In production, this would be the actual wasm-pack output
        // For POC, we'll create a mock that shows the interface
        // TODO: Replace with actual wasm-pack output when available
        const wasmModule: WasmModule = {
          PreviewRenderer: class MockPreviewRenderer implements PreviewRendererInstance {
            constructor(_canvas: HTMLCanvasElement, _width: number, _height: number) {}
            render_frame(_layersJson: string): void {}
            clear(): void {}
            get_metrics(): string { return JSON.stringify({}); }
            free(): void {}
          } as PreviewRendererConstructor,
          benchmark_composition: (_width: number, _height: number, _layerCount: number) => 0,
        };

        if (cancelled) return;

        wasmModuleRef.current = wasmModule as unknown as WasmModule;

        // Initialize renderer if canvas is available
        if (canvasRef.current && wasmModule.PreviewRenderer) {
          const renderer = new wasmModule.PreviewRenderer(canvasRef.current, width, height);
          rendererRef.current = renderer;

          const metricsStr = renderer.get_metrics();
          setMetrics(JSON.parse(metricsStr));
        }

        setIsLoading(false);
      } catch (err) {
        if (!cancelled) {
          console.error('Failed to load WASM module:', err);
          setError(err instanceof Error ? err : new Error(String(err)));
          setIsLoading(false);
        }
      }
    }

    loadWasm();

    return () => {
      cancelled = true;
      if (rendererRef.current) {
        rendererRef.current.free();
        rendererRef.current = null;
      }
    };
  }, [width, height]);

  /**
   * Render a frame with given layers
   */
  const renderFrame = useCallback(
    (layers: WasmLayer[]) => {
      if (!rendererRef.current) {
        console.warn('Renderer not initialized');
        return;
      }

      try {
        const startTime = performance.now();
        const layersJson = JSON.stringify(layers);
        rendererRef.current.render_frame(layersJson);
        const endTime = performance.now();

        const frameTime = endTime - startTime;
        const fps = 1000 / frameTime;

        setMetrics((prev) => ({
          ...prev!,
          lastFrameTime: frameTime,
          fps: Math.round(fps),
        }));
      } catch (err) {
        console.error('Render failed:', err);
        setError(err instanceof Error ? err : new Error(String(err)));
      }
    },
    []
  );

  /**
   * Clear the canvas
   */
  const clear = useCallback(() => {
    if (rendererRef.current) {
      rendererRef.current.clear();
    }
  }, []);

  /**
   * Run a benchmark test
   */
  const benchmark = useCallback(
    async (layerCount: number = 10): Promise<number> => {
      if (!wasmModuleRef.current) {
        throw new Error('WASM module not loaded');
      }

      return wasmModuleRef.current.benchmark_composition(width, height, layerCount);
    },
    [width, height]
  );

  return {
    canvasRef,
    renderFrame,
    clear,
    benchmark,
    isLoading,
    error,
    metrics,
  };
}

/**
 * Helper to create a default transform
 */
export function createTransform(overrides?: Partial<WasmTransform>): WasmTransform {
  return {
    x: 0,
    y: 0,
    scale_x: 1,
    scale_y: 1,
    rotation: 0,
    opacity: 1,
    ...overrides,
  };
}

/**
 * Helper to create a solid color layer
 */
export function createSolidColorLayer(
  color: [number, number, number, number],
  transform?: Partial<WasmTransform>,
  options?: { blendMode?: WasmLayer['blend_mode']; zIndex?: number }
): WasmLayer {
  return {
    id: Math.random().toString(36).substring(7),
    type: 'solidColor',
    color,
    transform: createTransform(transform),
    blend_mode: options?.blendMode || 'normal',
    visible: true,
    z_index: options?.zIndex || 0,
  };
}
